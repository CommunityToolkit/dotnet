// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Linq;
using System.Text;
using CommunityToolkit.Mvvm.SourceGenerators.ComponentModel.Models;
using CommunityToolkit.Mvvm.SourceGenerators.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CommunityToolkit.Mvvm.SourceGenerators;

/// <summary>
/// A source generator for message registration without relying on compiled LINQ expressions.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed partial class ObservableValidatorValidateAllPropertiesGenerator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get the types that inherit from ObservableValidator and gather their info
        IncrementalValuesProvider<ValidationInfo> validationInfo =
            context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax classDeclaration && classDeclaration.HasOrPotentiallyHasBaseTypes(),
                static (context, token) =>
                {
                    if (!context.SemanticModel.Compilation.HasLanguageVersionAtLeastEqualTo(LanguageVersion.CSharp8))
                    {
                        return default;
                    }

                    INamedTypeSymbol typeSymbol = (INamedTypeSymbol)context.SemanticModel.GetDeclaredSymbol(context.Node, token)!;

                    // Skip generating code for abstract types, as that would never be used. The methods that are generated by
                    // this generator are retrieved through reflection using the type of the invoking instance as discriminator,
                    // which means a type that is abstract could never be used (since it couldn't be instantiated).
                    if (typeSymbol is not { IsAbstract: false, IsGenericType: false })
                    {
                        return default;
                    }

                    // Just like in IMessengerRegisterAllGenerator, only select the first declaration for this type symbol
                    if (!context.Node.IsFirstSyntaxDeclarationForSymbol(typeSymbol))
                    {
                        return default;
                    }

                    // Only select types inheriting from ObservableValidator
                    if (!Execute.IsObservableValidator(typeSymbol))
                    {
                        return default;
                    }

                    return Execute.GetInfo(typeSymbol);
                })
            .Where(static item => item is not null)!;

        // Check whether the header file is needed
        IncrementalValueProvider<bool> isHeaderFileNeeded =
            validationInfo
            .Collect()
            .Select(static (item, _) => item.Length > 0);

        // Check whether [DynamicallyAccessedMembers] is available
        IncrementalValueProvider<bool> isDynamicallyAccessedMembersAttributeAvailable =
            context.CompilationProvider
            .Select(static (item, _) => item.HasAccessibleTypeWithMetadataName("System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute"));

        // Gather the conditional flag and attribute availability
        IncrementalValueProvider<(bool IsHeaderFileNeeded, bool IsDynamicallyAccessedMembersAttributeAvailable)> headerFileInfo =
            isHeaderFileNeeded.Combine(isDynamicallyAccessedMembersAttributeAvailable);

        // Generate the header file with the attributes
        context.RegisterConditionalImplementationSourceOutput(headerFileInfo, static (context, item) =>
        {
            CompilationUnitSyntax compilationUnit = Execute.GetSyntax(item);

            context.AddSource("__ObservableValidatorExtensions.g.cs", compilationUnit.GetText(Encoding.UTF8));
        });

        // Generate the class with all validation methods
        context.RegisterImplementationSourceOutput(validationInfo, static (context, item) =>
        {
            CompilationUnitSyntax compilationUnit = Execute.GetSyntax(item);

            context.AddSource($"{item.FilenameHint}.g.cs", compilationUnit.GetText(Encoding.UTF8));
        });
    }
}
